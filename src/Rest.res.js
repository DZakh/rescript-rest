// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml_option = require("rescript/lib/js/caml_option.js");
var S$RescriptSchema = require("rescript-schema/src/S.res.js");

async function $$default(args) {
  var match = args.body;
  var match$1 = args.body;
  var match$2 = args.headers;
  var tmp;
  if (match$1 !== undefined) {
    switch (match$1.TAG) {
      case "JsonString" :
          tmp = match$2 !== undefined ? Object.assign({
                  "content-type": "application/json"
                }, match$2) : ({
                "content-type": "application/json"
              });
          break;
      case "Text" :
      case "Blob" :
          tmp = match$2 !== undefined ? match$2 : undefined;
          break;
      
    }
  } else {
    tmp = match$2 !== undefined ? match$2 : undefined;
  }
  var result = await fetch(args.path, {
        method: args.method,
        body: match !== undefined ? match._0 : undefined,
        headers: tmp
      });
  var contentType = result.headers.get("content-type");
  if (contentType !== undefined) {
    var contentType$1 = Caml_option.valFromOption(contentType);
    if (contentType$1.includes("application/") && contentType$1.includes("json")) {
      return {
              body: {
                TAG: "JsonString",
                _0: await result.json()
              },
              status: result.status
            };
    }
    if (contentType$1.includes("text/")) {
      return {
              body: {
                TAG: "Text",
                _0: await result.text()
              },
              status: result.status
            };
    }
    
  }
  return {
          body: {
            TAG: "Blob",
            _0: await result.blob()
          },
          status: result.status
        };
}

var ApiFetcher = {
  $$default: $$default
};

function tokeniseValue(key, value, append) {
  if (Array.isArray(value)) {
    value.forEach(function (v, idx) {
          tokeniseValue(key + "[" + idx.toString() + "]", v, append);
        });
    return ;
  } else if (value === null) {
    return append(key, "");
  } else if (value === (void 0)) {
    return ;
  } else if (typeof value === "object") {
    Object.keys(value).forEach(function (k) {
          tokeniseValue(key + "[" + encodeURIComponent(k) + "]", value[k], append);
        });
    return ;
  } else {
    return append(key, value);
  }
}

function getCompletePath(baseUrl, routePath, maybeQuery, jsonQuery) {
  var path = baseUrl + routePath;
  if (maybeQuery !== undefined) {
    var queryItems = [];
    var append = function (key, value) {
      queryItems.push(key + "=" + encodeURIComponent(value));
    };
    var queryNames = Object.keys(maybeQuery);
    for(var idx = 0 ,idx_finish = queryNames.length; idx < idx_finish; ++idx){
      var queryName = queryNames[idx];
      var value = maybeQuery[queryName];
      var key = encodeURIComponent(queryName);
      if (value !== (void 0)) {
        if (jsonQuery) {
          append(key, typeof value === "string" && value !== "true" && value !== "false" && value !== "null" && Number.isNaN(Number(value)) ? value : JSON.stringify(value));
        } else {
          tokeniseValue(key, value, append);
        }
      }
      
    }
    if (queryItems.length > 0) {
      path = path + "?" + queryItems.join("&");
    }
    
  }
  return path;
}

function client(baseUrl, apiOpt, jsonQueryOpt) {
  var api = apiOpt !== undefined ? apiOpt : $$default;
  var jsonQuery = jsonQueryOpt !== undefined ? jsonQueryOpt : false;
  var initializedRoutes = new WeakMap();
  var getRouteParams = function (route) {
    var r = initializedRoutes.get(route);
    if (r !== undefined) {
      return r;
    }
    var routeDefinition = route();
    var variablesSchema = S$RescriptSchema.object(function (s) {
          return routeDefinition.variables({
                      field: (function (fieldName, schema) {
                          return s.nestedField("body", fieldName, schema);
                        }),
                      header: (function (fieldName, schema) {
                          return s.nestedField("headers", fieldName, schema);
                        }),
                      query: (function (fieldName, schema) {
                          return s.nestedField("query", fieldName, schema);
                        })
                    });
        });
    var params = {
      definition: routeDefinition,
      variablesSchema: variablesSchema
    };
    initializedRoutes.set(route, params);
    return params;
  };
  var call = function (route, variables) {
    var match = getRouteParams(route);
    var definition = match.definition;
    var data = S$RescriptSchema.serializeToUnknownOrRaiseWith(variables, match.variablesSchema);
    var body = data.body;
    var body$1 = body !== undefined ? ({
          TAG: "JsonString",
          _0: JSON.stringify(Caml_option.valFromOption(body))
        }) : undefined;
    return api({
                body: body$1,
                headers: data.headers,
                method: definition.method,
                path: getCompletePath(baseUrl, definition.path, data.query, jsonQuery)
              });
  };
  return {
          call: call,
          baseUrl: baseUrl,
          api: api,
          jsonQuery: jsonQuery
        };
}

exports.ApiFetcher = ApiFetcher;
exports.client = client;
/* S-RescriptSchema Not a pure module */
